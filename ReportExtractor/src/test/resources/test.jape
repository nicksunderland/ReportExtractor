Imports: {
	import static gate.Utils.*;

}


Phase: TagNumeric
Input: Token SpaceToken Split Lookup Units
Options: control=Appelt  negationGrouping=false

/*
 * Description:
 * Tag float/double values with annotation type 'Numeric' type="double"
 * We don't allow tagging of things like '3D' or '3-dimensional' or cm2 and so make
 * sure that the number is not within another Lookup or Units annotation.
 * To be as broad as possible, we allow accidental typing of spaces prior to a '.' or ',', 
 * but not spaces after, as that may tag numbers at the end of sentences or after 
 * commas; i.e. allow '12 .3' or '12 ,3' or '12.3' or '12,3'; but not '12, 3' or '12. 3'
 */
Rule: date_tagger_ddmmyyyy
Priority: 100
(
	// DD/MM/YYYY or DD/MM/YY

	({Token.kind == "number",
		Token.string ==~ "[12][0-9]|3[01]|0[1-9]|[1-9]", // day (allow single numbers, e.g. 5/7/22, as well as 05/07/22)
		Token notWithin Lookup, 
		Token notWithin Units}):day
	
	({Token.string ==~ "[./-]"} | {SpaceToken})
	
	({Token.kind == "number",
		Token.string ==~ "1[0-2]|0[1-9]|[1-9]", // month
		Token notWithin Lookup, 
		Token notWithin Units} | {Lookup.majorType == "month"}):month
	
	({Token.string ==~ "[./-]"} | {SpaceToken})
	
	({Token.kind == "number", // year YYYY
		Token.string ==~ "(19|20)[0-9][0-9]", 
		Token notWithin Lookup, 
		Token notWithin Units} |
	 {Token.kind == "number", // year YY
		Token.string ==~ "[0-9][0-9]", 
		Token notWithin Lookup, 
		Token notWithin Units}):year
				
	 ({!Token.string ==~ "[./-]"}{!Token.kind == "number"} | {Split})
	 
):date_tagger
-->
:date_tagger.Date = {type = "date", day = :day@cleanString, month = :month@cleanString, year = :year@cleanString}

Rule: date_tagger_ddmm
Priority: 100
(
	// DD/MM

	({Token.kind == "number",
		Token.string ==~ "[12][0-9]|3[01]|0[1-9]", // day (don't allow single numbers, e.g. 5/7, as easily could be a fraction)
		Token notWithin Lookup, 
		Token notWithin Units}):day
	
	({Token.string ==~ "[./-]"} | {SpaceToken})
	
	({Token.kind == "number",
		Token.string ==~ "1[0-2]|0[1-9]", // month
		Token notWithin Lookup, 
		Token notWithin Units} | {Lookup.majorType == "month"}):month
				
	 ({!Token.string ==~ "[./-]"}{!Token.kind == "number"} | {Split})
	 
):date_tagger
-->
:date_tagger.Date = {type = "date", day = :day@cleanString, month = :month@cleanString, year = null}

Rule: date_tagger_mmyyyy
Priority: 100
(
	({Token.kind == "number",
		Token.string ==~ "1[0-2]|0[1-9]", // month
		Token notWithin Lookup, 
		Token notWithin Units} | {Lookup.majorType == "month"}):month
	
	({Token.string ==~ "[./-]"} | {SpaceToken})
	
	({Token.kind == "number", // year YYYY
		Token.string ==~ "(19|20)[0-9][0-9]", 
		Token notWithin Lookup, 
		Token notWithin Units} |
	 {Token.kind == "number", // year YY
		Token.string ==~ "[0-9][0-9]", 
		Token notWithin Lookup, 
		Token notWithin Units}):year
	
	({!Token.string ==~ "[./-]"}{!Token.kind == "number"} | {Split})
	
):date_tagger
-->
:date_tagger.Date = {type = "date", day = null, month = :month@cleanString, year = :year@cleanString}

Rule: date_tagger_yyyy
Priority: 100
(	
	({Token.kind == "number", // year YYYY
		Token.string ==~ "(19|20)[0-9][0-9]", 
		Token notWithin Lookup, 
		Token notWithin Units}):year
	
	({!Token.string ==~ "[./-]"}{!Token.kind == "number"} | {Split})
	
):date_tagger
-->
:date_tagger.Date = {type = "date", day = null, month = null, year = :year@cleanString}

/*
 * Description:
 * Here we retag numeric ranges e.g. 50-50% as a Numeric annotation with a 'value' feature containing the mean
 */
Rule: numeric_ranges_rule
Priority: 99
(
	({Token.kind == "number"}({Token.string == "."}{Token.kind == "number"})?):lo
	({SpaceToken})?
	({Token.string ==~ "[-]|(to)"})
	({SpaceToken})?
	({Token.kind == "number"}({Token.string == "."}{Token.kind == "number"})?):hi

):numeric_range
-->
:numeric_range{
	
	String lo_str = stringFor(doc, bindings.get("lo"));
	String hi_str = stringFor(doc, bindings.get("hi"));
	String value  = null;
	try {
		Double lo = Double.parseDouble(lo_str);
		Double hi = Double.parseDouble(hi_str);
		Double av = (lo + hi) / 2.0;
		value = av.toString();
	}catch(Exception e) {
		return;
	}
	
	FeatureMap newFeatures = Factory.newFeatureMap();
	newFeatures.put("value", value);
	newFeatures.put("hi", hi_str);
	newFeatures.put("lo", hi_str);
	newFeatures.put("type", "range_value");
	outputAS.add(bindings.get("numeric_range").firstNode(),bindings.get("numeric_range").lastNode(),"Numeric", newFeatures);
}

/*
 * Description:
 * Here we retag orthogonal values as a specific Numeric annotations with 'value1' and 'value2' features
 */
Rule: orthogonal_dimension_rule
Priority: 99
(
	({Token.kind == "number"}({Token.string == "."}{Token.kind == "number"})?):value1
	({SpaceToken})?({Units.majorType == "length"})?({SpaceToken})?
	({Token.string ==~ "(?i)(x)|(by)"})
	({SpaceToken})?
	({Token.kind == "number"}({Token.string == "."}{Token.kind == "number"})?):value2

):orthogonal_numbers
-->
:orthogonal_numbers{
	
	String value1_str = stringFor(doc, bindings.get("value1"));
	String value2_str = stringFor(doc, bindings.get("value2"));
	try {
		Double value1 = Double.parseDouble(value1_str);
		Double value2 = Double.parseDouble(value2_str);
		value1_str = value1.toString();
		value2_str = value2.toString();
		
	}catch(Exception e) {
		return;
	}
	
	FeatureMap newFeatures = Factory.newFeatureMap();
	newFeatures.put("value1", value1_str);
	newFeatures.put("value2", value2_str);
	newFeatures.put("type", "orthogonal_numbers");
	outputAS.add(bindings.get("orthogonal_numbers").firstNode(),bindings.get("orthogonal_numbers").lastNode(),"Numeric", newFeatures);
}

Rule: weeks_fraction_shorthand
Priority: 98
(
	( {Token.string ==~ "[1234][0-9]|[5][0-2]|[1-9]"} ):numerator //1-52
	( {Token.string == "/"}
   	  ({Token.string ==~ "40"} | {Token.string ==~ "52"}) ):denominator  //40-pregnancy; 52-weeks in year

):fraction_shorthand
-->
:fraction_shorthand{
	
	String num_weeks_str = stringFor(doc, bindings.get("numerator"));
	try {
		int num_weeks = Integer.parseInt(num_weeks_str);
		num_weeks_str = String.valueOf(num_weeks);
	}catch(Exception e) {
		return;
	}
	
	// Add the Numeric annotations to the numerator
	FeatureMap newFeatures = Factory.newFeatureMap();
	newFeatures.put("value", num_weeks_str);
	newFeatures.put("type", "integer");
	outputAS.add(bindings.get("numerator").firstNode(),bindings.get("numerator").lastNode(),"Numeric", newFeatures);
	
	// Add a Lookup annotation to the denominator
	FeatureMap newFeatures_2 = Factory.newFeatureMap();
	newFeatures_2.put("majorType", "time");
	newFeatures_2.put("minorType", "weeks");
	newFeatures_2.put("language", "en");
	outputAS.add(bindings.get("denominator").firstNode(),bindings.get("denominator").lastNode(),"Units", newFeatures_2);
}

Rule: fraction_tagger
Priority: 96
(
	(({Token.kind == "number", 
		Token notWithin Lookup,
		Token notWithin Date,
		Token notWithin Units}):main
	{SpaceToken})?
	({Token.kind == "number", 
		Token notWithin Lookup,
		Token notWithin Date,
		Token notWithin Units}):numerator
	{Token.string == "/"} 
	({Token.kind == "number", 
		Token notWithin Lookup,
		Token notWithin Date,
		Token notWithin Units} |
	 {Token.string ==~ "(?i)[0-9]*(st|nd|rd|th)(s)?", 
	 	Token notWithin Lookup,
	 	Token notWithin Date,
	 	Token notWithin Units}):denominator
	
):fraction_tagger
-->
:fraction_tagger{
	
	String main_str = bindings.get("main")!=null ? stringFor(doc, bindings.get("main")) : "0";
	String numerator_str = stringFor(doc, bindings.get("numerator"));
	String denominator_str = stringFor(doc, bindings.get("denominator")).replaceAll("(st|nd|rd|th)(s)?","");
	String value = null;
	try {
		Double main = Double.parseDouble(main_str);
		Double numerator = Double.parseDouble(numerator_str);
		Double denominator = Double.parseDouble(denominator_str);
		main = main + (numerator/denominator);
		value = main.toString();
	}catch(Exception e) {
		return;
	}
	FeatureMap newFeatures = Factory.newFeatureMap();
	newFeatures.put("value", value);
	newFeatures.put("type", "fraction");
	outputAS.add(bindings.get("fraction_tagger").firstNode(),bindings.get("fraction_tagger").lastNode(),"Numeric", newFeatures);
}


Rule: double_tagger
Priority: 95
(
	{Token.kind == "number", 
		Token notWithin Lookup, 
		Token notWithin Units} 
	({SpaceToken, !Split})[0,1] 
	{Token.string ==~ "[.,]"} 
	{Token.kind == "number", 
		Token notWithin Lookup, 
		Token notWithin Units}
	({SpaceToken}
	 {Token.string == "0",   //allow a space then a 0 (as this won't change the value), but not other numbers
		Token notWithin Lookup, 
		Token notWithin Units})?
	
):double_tagger
-->
:double_tagger.Numeric = {type = "double", value = :double_tagger@cleanString}

/*
 * Description:
 * If the double_tagger rule does not fire, then we come here to tag numbers on their
 * own as Numeric with type="integer"
 */
Rule: int_tagger
Priority: 94
(
	{Token.kind == "number", 
		Token notWithin Lookup, 
		Token notWithin Units}
):int_tagger
-->
:int_tagger.Numeric = {type = "integer", value = :int_tagger@cleanString}


Phase: CleanUnits
Input: Units
Options: control=Appelt negationGrouping=false
/*
 * Description:
 * Here we remove units within units and assume that the large spanning annotation
 * is correct. 
 * e.g. 'cm/m' may get tagged as 'cm', 'm', and 'cm/m' ==> just 'cm/m'
 */
Rule: clean_units
Priority: 100
(
	{Units}
):unit
-->
{
	AnnotationSet unitAnnots    = bindings.get("unit");
	
	AnnotationSet unitsWithin_1 = inputAS.get("Units").getContained(
			unitAnnots.firstNode().getOffset(),
			unitAnnots.lastNode().getOffset()-1);
	inputAS.removeAll(unitsWithin_1);
	
	AnnotationSet unitsWithin_2 = inputAS.get("Units").getContained(
			unitAnnots.firstNode().getOffset()+1,
			unitAnnots.lastNode().getOffset());
	inputAS.removeAll(unitsWithin_2);
}



Phase: CleanAnatomy
Input: Anatomy
Options: control=Appelt negationGrouping=false
/*
 * Description:
 * Here we remove anatomy within anatomy and assume that the larger spanning annotation
 * is correct. 
 */
Rule: clean_anatomy
Priority: 100
(
	{Anatomy}
):anatomy
-->
{
	AnnotationSet anatomyAnnots = bindings.get("anatomy");
	
	AnnotationSet anatomyWithin_1 = inputAS.get("Anatomy").getContained(
			anatomyAnnots.firstNode().getOffset(),
			anatomyAnnots.lastNode().getOffset()-1);
	inputAS.removeAll(anatomyWithin_1);
	
	AnnotationSet anatomyWithin_2 = inputAS.get("Anatomy").getContained(
			anatomyAnnots.firstNode().getOffset()+1,
			anatomyAnnots.lastNode().getOffset());
	inputAS.removeAll(anatomyWithin_2);
	
	AnnotationSet unitsWithinAnatomy = inputAS.get("Units").getContained(
			anatomyAnnots.firstNode().getOffset(),
			anatomyAnnots.lastNode().getOffset());
	inputAS.removeAll(unitsWithinAnatomy);
}

Phase: CleanNumeric
Input: Numeric Units Token Split
Options: control=Appelt negationGrouping=false
/*
 * Description:
 * Here we retag split numeric values e.g. 1m 80cm ({Numeric}{Units}{Numeric}{Units}) becomes 1.8m {Numeric}{Units}
 * To keep it compatible with the Context:Numeric:Units matching we assign the 'value' feature of the metre annotation
 * to a combination of the metre and cm; then remove annots from the '80' and the 'cm' so they effectively get ignored.
 * is correct. 
 */
Rule: split_metric_length
(
	({Numeric}):metres		 
	({Units.minorType == "m"})
	({Numeric}):cm
	({Units.minorType == "cm"})?

):split_metric
-->
:split_metric{
	
	String metres_str = stringFor(doc, bindings.get("metres"));
	String cm_str     = bindings.get("cm")!=null ? stringFor(doc, bindings.get("cm")) : "0";
	String value = null;
	try {
		Double metres = Double.parseDouble(metres_str);
		Double cm     = Double.parseDouble(cm_str);
		metres = metres + (cm / 100.0);
		value = metres.toString();
	}catch(Exception e) {
		return;
	}
	FeatureMap newFeatures = Factory.newFeatureMap();
	newFeatures.put("value", value);
	newFeatures.put("type", "split_value");
	outputAS.add(bindings.get("metres").firstNode(),bindings.get("metres").lastNode(),"Numeric", newFeatures);

	
	// Since now the data lives in the new Numeric annotation's feature, we can clean up and remove the Numeric / Units annots	
	AnnotationSet splitMetricAnnot = bindings.get("split_metric");
	
	FeatureMap fm_double = Factory.newFeatureMap();
	fm_double.put("type", "double");
	AnnotationSet doubleWithin = inputAS.get("Numeric", fm_double).getContained(
			splitMetricAnnot.firstNode().getOffset(),
			splitMetricAnnot.lastNode().getOffset());
	inputAS.removeAll(doubleWithin);
	
	FeatureMap fm_integer = Factory.newFeatureMap();
	fm_integer.put("type", "integer");
	AnnotationSet integerWithin = inputAS.get("Numeric", fm_integer).getContained(
			splitMetricAnnot.firstNode().getOffset(),
			splitMetricAnnot.lastNode().getOffset());
	inputAS.removeAll(integerWithin);
	
	FeatureMap fm_cm = Factory.newFeatureMap();
	fm_cm.put("minorType", "cm");
	AnnotationSet cmUnitsWithin = inputAS.get("Units", fm_cm).getContained(
			splitMetricAnnot.firstNode().getOffset(),
			splitMetricAnnot.lastNode().getOffset());
	inputAS.removeAll(cmUnitsWithin);
}


/*
 * Description:
 * Here we retag Numeric annotations that should be part of a broader descriptor
 * e.g. type 1 or type 2 etc.. 
 */
Rule: numeric_type_rule
(
	{Token.string ==~ "(?i)type"}
	({Numeric}):value		 

):numeric_type
-->
:numeric_type.Lookup = {majorType = "numeric_type", minorType = :value.Numeric.value},
:numeric_type{
	inputAS.remove( bindings.get("value").iterator().next() );
}


Phase: ImageFrameNumericReferences
Input: Numeric Token Lookup
Options: control=Brill negationGrouping=false
/*
 * Description:
 * Tag references to specific images or frames and remove the numeric tag
 */
Rule: image_frame_tagger
(	
	{Lookup.majorType == "image_frame"}
	
	({Token.kind == "number", 
		Token notWithin Lookup, 
		Token notWithin Units}
	 ({Token.kind == "punctuation"}|{Lookup.minorType == "conjunction"}))[0,3]
				
	({Token.kind == "number", 
		Token notWithin Lookup, 
		Token notWithin Units}):image_num

):image_frame
-->
:image_frame{
	
	FeatureMap newFeatures = Factory.newFeatureMap();
	newFeatures.put("value", stringFor(doc, bindings.get("image_num")));
	newFeatures.put("majorType", "image_frame_value");
	newFeatures.put("minorType", "image_frame_value");
	outputAS.add(bindings.get("image_frame").firstNode(),bindings.get("image_frame").lastNode(),"Lookup", newFeatures);

	// Since now the data lives in the new Numeric annotation's feature, we can clean up and remove the Numeric / Lookup annots
	AnnotationSet imageFrameAnnot = bindings.get("image_frame");
	
	AnnotationSet numericWithin = inputAS.get("Numeric").getContained(
			imageFrameAnnot.firstNode().getOffset(),
			imageFrameAnnot.lastNode().getOffset());
	inputAS.removeAll(numericWithin);
}


Phase: RelationalDistance
Input: Numeric Token Lookup Anatomy Units Split
Options: control=Brill negationGrouping=false
/*
 * Description:
 * Tag references to distances in relation to something else, these rarely are the numeric value we want 
 * e.g. the Asc Ao measured 1cm from the StJ is 33mm (we want to tag the 1cm as a relational distance and 
 * the 33mm as a normal integer Numeric annotation which can be found later
 */
Rule: relational_distance_rule
(	
	({Anatomy}):anatomy1
	({Token, !Split})[0,1]
	{Lookup.majorType == "measure_verb"}
	({Numeric}):distance
	(({Units.majorType == "length"})?):units
	{Lookup.minorType == "preposition", //e.g. from
		!Token.string ==~ "(at)|(on)"}
	({Anatomy}):anatomy2

):relational_distance
-->
:relational_distance.Lookup = {	 anatomy1  = :anatomy1.Anatomy.minorType,
				 			     anatomy2  = :anatomy2.Anatomy.minorType,
				 			     distance  = :distance.Numeric.value,
				 				 units     = :units.Units.minorType,
				 				 majorType = "relational_distance"},
:relational_distance{
	inputAS.remove( bindings.get("distance").iterator().next() );
	inputAS.remove( bindings.get("anatomy2").iterator().next() );
	if(bindings.get("units")!=null) {
		inputAS.remove(bindings.get("units").iterator().next());
	}
}

Phase: TagImperialLength
Input: Numeric Units Token Split
Options: control=Appelt negationGrouping=false
/*
 * Description:
 * Tag imperial measurements in feet +/- inches
 */
Rule: imperial_length_1
(
	({Numeric}):feet		 
	{Units.minorType == "feet"}
	(({Numeric})?):inches
	({Units.minorType == "inches"})?

):imperial_length
-->
:imperial_length{
		FeatureMap newFeatures = Factory.newFeatureMap();
		newFeatures.put("majorType","length");
		newFeatures.put("feet", bindings.get("feet").iterator().next().getFeatures().get("value"));
		newFeatures.put("inches", bindings.get("inches")!=null ? bindings.get("inches").iterator().next().getFeatures().get("value") : null);
		outputAS.add(bindings.get("imperial_length").firstNode(),bindings.get("imperial_length").lastNode(),"ImperialMeasurement", newFeatures);
		
		// Since now the data lives in the ImperialMeasurement annotation's feature, we can clean up and remove the Numeric / Units annots
		AnnotationSet numericWithin = bindings.get("imperial_length").get("Numeric");
		AnnotationSet unitsWithin = bindings.get("imperial_length").get("Units");
		inputAS.removeAll(numericWithin);
		inputAS.removeAll(unitsWithin);
}

/*
 * Description:
 * Tag imperial measurements in inches +/- feet
 */
Rule: imperial_length_2
(
	(({Numeric})?):feet		 
	({Units.minorType == "feet"})?
	({Numeric}):inches
	{Units.minorType == "inches"}

):imperial_length
-->
:imperial_length{
		FeatureMap newFeatures = Factory.newFeatureMap();
		newFeatures.put("majorType","length");
		newFeatures.put("feet", bindings.get("feet")!=null ? bindings.get("feet").iterator().next().getFeatures().get("value") : null);
		newFeatures.put("inches", bindings.get("inches").iterator().next().getFeatures().get("value"));
		outputAS.add(bindings.get("imperial_length").firstNode(),bindings.get("imperial_length").lastNode(),"ImperialMeasurement", newFeatures);
		
		// Since now the data lives in the ImperialMeasurement annotation's feature, we can clean up and remove the Numeric / Units annots
		AnnotationSet numericWithin = bindings.get("imperial_length").get("Numeric");
		AnnotationSet unitsWithin = bindings.get("imperial_length").get("Units");
		inputAS.removeAll(numericWithin);
		inputAS.removeAll(unitsWithin);
}


Phase: TagImperialWeight
Input: Numeric Units Token Split
Options: control=Appelt negationGrouping=false

/*
 * Description:
 * Tag imperial measurements in stone and pounds (allowing a token inbetween, e.g. comma or fullstop)
 */
Rule: imperial_weight_0
(
		({Numeric}):stone		 
		{Units.minorType == "stone"}
		({Token.string ==~ "[&,.]|(and)"})?
		({Numeric}):pounds
		{Units.minorType == "pounds"}

):imperial_weight
-->
:imperial_weight{
		FeatureMap newFeatures = Factory.newFeatureMap();
		newFeatures.put("majorType","mass");
		newFeatures.put("stone", bindings.get("stone").iterator().next().getFeatures().get("value"));
		newFeatures.put("pounds", bindings.get("pounds")!=null ? bindings.get("pounds").iterator().next().getFeatures().get("value") : null);
		outputAS.add(bindings.get("imperial_weight").firstNode(),bindings.get("imperial_weight").lastNode(),"ImperialMeasurement", newFeatures);
		
		// Since now the data lives in the ImperialMeasurement annotation's feature, we can clean up and remove the Numeric / Units annots
		AnnotationSet numericWithin = bindings.get("imperial_weight").get("Numeric");
		AnnotationSet unitsWithin = bindings.get("imperial_weight").get("Units");
		inputAS.removeAll(numericWithin);
		inputAS.removeAll(unitsWithin);
}

/*
 * Description:
 * Tag imperial measurements in stone +/- pounds
 */
Rule: imperial_weight_1
(
	({Numeric}):stone		 
	{Units.minorType == "stone"}
	(({Numeric})?):pounds
	({Units.minorType == "pounds"})?

):imperial_weight
-->
:imperial_weight{
		FeatureMap newFeatures = Factory.newFeatureMap();
		newFeatures.put("majorType","mass");
		newFeatures.put("stone", bindings.get("stone").iterator().next().getFeatures().get("value"));
		newFeatures.put("pounds", bindings.get("pounds")!=null ? bindings.get("pounds").iterator().next().getFeatures().get("value") : null);
		outputAS.add(bindings.get("imperial_weight").firstNode(),bindings.get("imperial_weight").lastNode(),"ImperialMeasurement", newFeatures);
		
		// Since now the data lives in the ImperialMeasurement annotation's feature, we can clean up and remove the Numeric / Units annots
		AnnotationSet numericWithin = bindings.get("imperial_weight").get("Numeric");
		AnnotationSet unitsWithin = bindings.get("imperial_weight").get("Units");
		inputAS.removeAll(numericWithin);
		inputAS.removeAll(unitsWithin);
}

/*
 * Description:
 * Tag imperial measurements in pounds +/- stone
 */
Rule: imperial_weight_2
(
	(({Numeric})?):stone		 
	({Units.minorType == "stone"})?
	({Numeric}):pounds
	{Units.minorType == "pounds"}

):imperial_weight
-->
:imperial_weight{
		FeatureMap newFeatures = Factory.newFeatureMap();
		newFeatures.put("majorType","mass");
		newFeatures.put("stone", bindings.get("stone")!=null ? bindings.get("stone").iterator().next().getFeatures().get("value") : null);
		newFeatures.put("pounds", bindings.get("pounds").iterator().next().getFeatures().get("value"));
		outputAS.add(bindings.get("imperial_weight").firstNode(),bindings.get("imperial_weight").lastNode(),"ImperialMeasurement", newFeatures);
		
		// Since now the data lives in the ImperialMeasurement annotation's feature, we can clean up and remove the Numeric / Units annots
		AnnotationSet numericWithin = bindings.get("imperial_weight").get("Numeric");
		AnnotationSet unitsWithin = bindings.get("imperial_weight").get("Units");
		inputAS.removeAll(numericWithin);
		inputAS.removeAll(unitsWithin);
}



/* This phase extends the Anatomy annotations based of things found within
 * the Aorta Report Section. e.g. "sinuses" could have a number of meanings if 
 * found elsewhere within a report, however if "sinuses" are found within the
 * "AORTA:" report section or a sentence talking about an aorta then it is 
 * highly likely that it is referring to the sinuses of Valsalva.
 */
Phase: TagVarSentence
Input: Sentence Anatomy
Options: control=Appelt negationGrouping=false
/*
 * Description:
 * Sentence that contains 'aorta' phrases
 */
Rule: var_sentence
(
	{Sentence contains {Anatomy.majorType == "aorta"}}
	({Sentence notContains {Anatomy.majorType != "aorta"}})?
	
):var_sentence
-->
:var_sentence.VarSentence = {type = "aorta"}



Phase: ExtendAnatomyAnnotations
Input: Token ReportSection VarSentence Lookup Anatomy
Options: control=first negationGrouping=false
/*
 * Description:
 * Tag 'root' and 'sinus' as relating to the aorta if it appears in a
 * sentence or report sections about aortas
 */
Rule: ext_anat_annots_1
(
	{Token.string ==~ "(?i)sinus(es)?", 
		Token within {ReportSection.type == "aorta"}, 
		Token notWithin {Anatomy.minorType == "sinus_of_valsalva"},
		Token notWithin {Lookup.majorType == "cardiac_rhythm"}} |
	{Token.string ==~ "(?i)sinus(es)?", 
		Token within {VarSentence.type == "aorta"}, 
		Token notWithin {Anatomy.minorType == "sinus_of_valsalva"},
		Token notWithin {Lookup.majorType == "cardiac_rhythm"}}

):ext_anat_annots
-->
:ext_anat_annots.Anatomy = {language = "en", majorType = "aorta", minorType = "sinus_of_valsalva"}

/*
 * Description:
 * Tag 'root' and 'sinus' as relating to the aorta if it appears in a
 * sentence or report sections about aortas
 */
Rule: ext_anat_annots_2
(
	{Token.string ==~ "(?i)root",
		Token notWithin {Anatomy.minorType == "aortic_root"},
		Token within {ReportSection.type == "aorta"}} |
	{Token.string ==~ "(?i)root",
		Token notWithin {Anatomy.minorType == "aortic_root"},
		Token within {VarSentence.type == "aorta"}}

):ext_anat_annots
-->
:ext_anat_annots.Anatomy = {language = "en", majorType = "aorta", minorType = "aortic_root"}










Phase: TagVarSentence
Input: Sentence Anatomy
Options: control=Appelt negationGrouping=false
/*
 * Description:
 * Tag sentences that contain a mention of height, or simply 'patient',
 * e.g. height is 150cm
 * e.g. the patient is 159cm
 */
Rule: var_sentence
(
	{Sentence contains {Anatomy.minorType == "ascending_aorta"}}
	({Sentence notContains {Anatomy.minorType != "ascending_aorta"}})?
					
):var_sentence
-->
:var_sentence.VarSentence = {type = "ascending_aorta"}




Phase: Test1
Input: Token Anatomy Numeric Units Lookup VarSentence Split
Options: control=Appelt negationGrouping=false

Macro: CONTEXT
(
	{Anatomy,
		Anatomy within {VarSentence.type == "ascending_aorta"},
		Anatomy.minorType == "ascending_aorta"}
)

Macro: FILTER
(
	{Token,
		!Numeric, //force carry on
		!Units.majorType == "length", //force carry on
		!Anatomy.minorType != "ascending_aorta",
		!Lookup.majorType == "height",
		!Lookup.majorType == "body_surface_area",
		!Units.majorType == "length/length", 
		!Units.majorType == "z_score", 
		!Lookup.majorType == "quantity_change",
		!Split,
		Token within {VarSentence.type == "ascending_aorta"}}
)

Macro: VALUE
(
	{Numeric, 
		Numeric within {VarSentence.type == "ascending_aorta"},
		Numeric.type == "double"} |
	{Numeric,
		Numeric within {VarSentence.type == "ascending_aorta"}, 
		Numeric.type == "integer"}
)

Macro: UNITS
(
	{Units,
		Units within {VarSentence.type == "ascending_aorta"},
		Units.majorType == "length"}
)


Rule: ao_idx_asc_blocker
Priority: 100
(	
	{Lookup.majorType == "indexed", 
		Lookup within {VarSentence.type == "ascending_aorta"}}
	{Anatomy,
		Anatomy within {VarSentence.type == "ascending_aorta"},
		Anatomy.minorType == "ascending_aorta"}
):asc_blocker
-->
:asc_blocker.Blocked = {}


/*
 * Description:
 * e.g. 'the root is dilated at 45mm at the Sov'
 */
Rule: test_1
Priority:100
(
	( CONTEXT ):context
			
	( FILTER )[0,15]
	
	( VALUE ):value
			
	( (UNITS)? ):unit
			
	({Token, 
		!Lookup.minorType == "preposition",
		!Anatomy.majorType == "misc_echo_descriptor",
		!Units} | {Split})
		
):test_var 
--> 
:test_var
  {
	gate.AnnotationSet matchedVar    =(gate.AnnotationSet) bindings.get("value");
	gate.AnnotationSet matchedcontext=(gate.AnnotationSet) bindings.get("context");
	gate.AnnotationSet matchedunit   =(gate.AnnotationSet) bindings.get("unit");
    gate.AnnotationSet matchedAnns   =(gate.AnnotationSet) bindings.get("test_var");	
	gate.FeatureMap newFeatures      = Factory.newFeatureMap();
	newFeatures.put("varType","test_var");
	String value_feature = (String) matchedVar.iterator().next().getFeatures().get("value");
	newFeatures.put("varValue", value_feature);
	newFeatures.put("context", stringFor(doc, matchedcontext));
	if(matchedunit != null) {
		newFeatures.put("unit", stringFor(doc, matchedunit));
	}else {
		newFeatures.put("unit", null);
	}
	outputAS.add(matchedAnns.firstNode(),matchedAnns.lastNode(),"test", newFeatures);
	
	doc.getFeatures().put("var_found", true);

  }



Rule: test_2
Priority: 99
(	
	// General aortic root context
	(
		{Anatomy,
			Anatomy.minorType == "aortic_root",
			Anatomy notWithin {Anatomy.minorType != "aortic_root"}}
	)
	
	( FILTER )[0,5]
	
	( VALUE ):value
			
	( (UNITS)? ):unit

	{Lookup.minorType == "preposition"} //Preposition leading into the actual specific context 
	
	( FILTER )[0,5]
	
	( CONTEXT ):context
		
):test_var 
--> 
:test_var
  {
	
	gate.AnnotationSet matchedVar    =(gate.AnnotationSet) bindings.get("value");
	gate.AnnotationSet matchedcontext=(gate.AnnotationSet) bindings.get("context");
	gate.AnnotationSet matchedunit   =(gate.AnnotationSet) bindings.get("unit");
    gate.AnnotationSet matchedAnns   =(gate.AnnotationSet) bindings.get("test_var");	
	gate.FeatureMap newFeatures      = Factory.newFeatureMap();
	newFeatures.put("varType","test_var");
	newFeatures.put("varValue", stringFor(doc, matchedVar));
	newFeatures.put("context", stringFor(doc, matchedcontext));
	if(matchedunit != null) {
		newFeatures.put("unit", stringFor(doc, matchedunit));
	}else {
		newFeatures.put("unit", null);
	}
	outputAS.add(matchedAnns.firstNode(),matchedAnns.lastNode(),"test", newFeatures);
	
	doc.getFeatures().put("var_found", true);
  }



//Phase: AorticRootDiameter
//Input: Token Anatomy Numeric Units Lookup VarSentence Split ImperialMeasurement ReportSection Measurement
//Options: control=once negationGrouping=false
//
///*
// * Description:
// * Block obvious other things such as weight
// */
//Rule: blocker_1
//Priority: 100
//(
//	( CONTEXT ):context
//	
//	( {Token within {VarSentence.type == "height"}} )[0,1]
//			
//	(
//		{Lookup.minorType == "weight"} |
//		{Lookup.minorType == "body_surface_area"}
//	)
//	
//	( METRIC_WEIGHT )
//		
//):blocker
//-->
//:blocker.Blocked = {}
//
//Rule: test_3
//Priority: 99
//(	
//	( CONTEXT ):context
//
//	( {Token within {VarSentence.type == "weight"}} )[0,1]
//		
//	( METRIC_WEIGHT ):value
//	
//	{!Units.majorType != "mass"} // make sure not some other non-mass units
//		
//):test_var 
//--> 
//:test_var
//  {
//	if( doc.getFeatures().containsKey("var_found") ) {
//		doc.getFeatures().remove("var_found");
//		return;
//	}
//	
//	gate.AnnotationSet matchedVar    =(gate.AnnotationSet) bindings.get("value");
//	gate.AnnotationSet matchedcontext=(gate.AnnotationSet) bindings.get("context");
//	gate.AnnotationSet matchedunit   =(gate.AnnotationSet) bindings.get("unit");
//    gate.AnnotationSet matchedAnns   =(gate.AnnotationSet) bindings.get("test_var");	
//	gate.FeatureMap newFeatures      = Factory.newFeatureMap();
//	newFeatures.put("varType","test_var");
//	String value_feature = (String) matchedVar.iterator().next().getFeatures().get("value");
//	newFeatures.put("varValue", value_feature);
//	newFeatures.put("context", stringFor(doc, matchedcontext));
//	if(matchedunit != null) {
//		newFeatures.put("unit", stringFor(doc, matchedunit));
//	}else {
//		newFeatures.put("unit", null);
//	}
//	outputAS.add(matchedAnns.firstNode(),matchedAnns.lastNode(),"test", newFeatures);
//	
//  }